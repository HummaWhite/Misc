# M

拓扑排序 + 并查集

看到这种大小关系我们就想到建边。由于最后求答案的时候要从小的往上找，为了使最小的深度为1，当A < B时建一条有向边。等于的时候怎么搞呢？用并查集合并，维护一下有几个点合并在这个点就行了。那么对于输入中起点和终点分别为u和v的边，实际上要加find(u)到find(v)的边。

对于A > B， B = C， C = A这种关系，合并后就变成一个自环，可以直接判断出不能拓扑排序。所以在加完所有的边后先扫一遍每条边的起点和终点判断是不是同一集合。

如果可以拓扑排序，就在排序的时候维护一下每个点的深度（最小的点为1，所有点初始化深度为1），最后答案就是$\sum{dep_i * size_i}$。对于图不连通的情况，每个单独块在拓扑排序之后都会有从1开始的深度所得的答案，满足题意，所以不用考虑连通性。

